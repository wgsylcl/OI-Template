# 线段树优化DP

一些动态规划问题的转移可以转化为动态的区间修改与查询，这时便可以利用线段树来加速了

下面是一些例子
```admonish question title = "[CF833B The Bakery](https://codeforces.com/problemset/problem/833/B)"
将一个长度为 $n$ 的序列分为 $k$ 段，使得总价值最大。

一段区间的价值表示为区间内不同数字的个数。

数据范围：$n \leq 35000, k \leq 50$
```

我们记$w(i, j)$为$[l, r]$内不同数字的个数，那么设$f_{i,k}$为将前$i$个数分成$j$段所能得到的最大总价值

那么容易得出转移方程
$$f_{i,k + 1} = \max_{0 \le j < i}\{f_{j,k} + w(j + 1, i)\}$$

我们发现$w(i,j)$很难在短时间内重复计算，那么我们换个思路，每个数会对哪些地方的$w(i,j)$值产生贡献？

记这个序列为$a_1,a_2,\ldots,a_n$，记$lst_i$为$1 \sim i-1$中$a_i$出现的最右侧位置的下标**加一**，那么$a_i$会对$j \in [lst_i, i], t \in [i, n]$的$w(j, t)$产生$1$的贡献

然后上面的求$\max$就成了$f_{0, \ldots ,i - 1}$里面取最大值

这是一个区间加与区间查最大值，显然可以用线段树优化

那么直接暴力枚举$k$，每次先清空，然后用线段树维护$f_{k - 1, j - 1} + w(j, i)$的值

考虑让$i$从$1$循环到$n$，先让$[lst_i, i]$加一，然后在$[0,i]$里面查询最大值记到$f_{k,i}$里面就行

时间复杂度$O(kn\log n)$，代码如下：

```admonish code
~~~cpp
{{#include ./code/CF833B.cpp}}
~~~
```

再来一题

```admonish question title = "[P2605 [ZJOI2010] 基站选址](https://www.luogu.com.cn/problem/P2605)"

有 $N$ 个村庄坐落在一条直线上，第 $i(i>1)$ 个村庄距离第 $1$ 个村庄的距离为 $D_i$。需要在这些村庄中建立不超过 $K$ 个通讯基站，在第 $i$ 个村庄建立基站的费用为 $C_i$。如果在距离第 $i$ 个村庄不超过 $S_i$ 的范围内建立了一个通讯基站，那么就村庄被基站覆盖了。如果第 $i$ 个村庄没有被覆盖，则需要向他们补偿，费用为 $W_i$。现在的问题是，选择基站的位置，使得总费用最小。

$100\%$ 的数据中，$K\leq N$，$K\leq 100$，$N\leq 2\times 10^4$，$D_i \leq 10^9$，$C_i\leq 10^4$，$S_i \leq10^9$，$W_i \leq 10^4$。
```

我们设$f_{i,j}$表示第$j$个基站建立在$i$位置，考虑$[1, i]$位置产生的最小总费用。

容易写出转移方程
$$f_{i,k} = \min_{j = 1}^{k-1}\{f_{j,k - 1} + cost(j,i)\} + c_i$$

其中$cost(j,i)$为$[j + 1,i - 1]$区间中因为信号覆盖不到产生的总赔偿费用，$c_i$为在$i$处建基站的费用。

看到式子里有$\min$，并且显然$1\le k\le i - 1$，很容易想到用线段树来处理，但是又发现这个$cost(k,i)$不太好维护。下面重点说说这个怎么处理。

我们不直接计算$cost(j,i)$，而是考虑这样一个问题，对于一个村庄$x$，什么时候它会产生赔偿$w_x$？

我们先预处理出最左边和最右边的信号能覆盖到$x$的村庄编号$L_x$和$R_x$，那么当$k<L_x$且$i>R_x$时，会产生赔偿$w_x$。放在线段树上处理就是：当$i = R_x+1$时，我们就让线段树上$[1, L_x-1]$的位置加上$w_x$，表示如果上一个基站建在$[1,L_x-1]$的位置的话，那么$w_x$就会产生贡献了。 那么如何方便地找到刚好在$i - 1$位置的那些$R_x$呢？用一个`vector`来存就可以了。

这里运用一个小技巧，让$n \leftarrow n + 1$，$k \leftarrow k + 1$，然后在新的$n$位置加一个虚拟村庄，最后答案就是$ans = f[n]$，因为是让第$k + 1$个虚拟基站建在这个虚拟村庄这里，用于收集答案。

```admonish code
~~~cpp
{{#include ./code/Luogu_P_2605.cpp}}
~~~
```

小练习

```admonish question title = "[P9871 [NOIP2023] 天天爱打卡](https://www.luogu.com.cn/problem/P9871)"
小 T 同学非常热衷于跑步。为了让跑步更加有趣，他决定制作一款叫做《天天爱打卡》的软件，使得用户每天都可以进行跑步打卡。

开发完成后，小 T 同学计划进行试运行，他找了大 Y 同学来帮忙。试运行共 $n$ 天，编号为从 $1$ 到 $n$。

对大 Y 同学来说，如果某天他选择跑步打卡，那么他的能量值会减少 $d$。初始时，他的能量值是 $0$，并且试运行期间他的**能量值可以是负数**。

而且大 Y 不会**连续**跑步打卡**超过** $k$ 天；即不能存在 $1\le x\le n-k$，使得他在第 $x$ 到第 $x+k$ 天均进行了跑步打卡。

小 T 同学在软件中设计了 $m$ 个挑战，第 $i$（$1\le i \le m$）个挑战可以用三个正整数 $(x_i,y_i,v_i)$ 描述，表示如果在第 $x_i$ 天时，用户已经连续跑步打卡至少 $y_i$ 天（即第 $x_i-y_i+1$ 到第 $x_i$ 天均完成了跑步打卡），那么小 T 同学就会请用户吃饭，从而使用户的能量值提高 $v_i$。

现在大 Y 想知道，在软件试运行的 $n$ 天结束后，他的能量值**最高**可以达到多少？

**本题有$t$组测试数据。**

记 $l_i=x_i-y_i+1$，$r_i=x_i$​；

对于所有测试数据，保证：$1\le t\le 10$，$1\le k\le n\le 10^9$，$1\le m\le 10^5$，$1\le l_i\le r_i\le n$，$1\le d,v_i\le 10^9$。
```

```admonish tip
考虑设dp状态$f_i$为考虑前$i$天且强制第$i$天跑步的最大值，同样设$g_i$（未明确说明$g_i$具体定义，但从转移方程推测$g_i$应与$i$天内跑步情况相关）。
易得一个转移方程：
$$f_i=\max_{j = i - k}^{i - 1}\{g_{j - 1}-(i - j)\cdot d+\sum_{[l_p,r_p]\subseteq(j,i]}v_p\}$$
也就是强制第$i$天跑步，且第$j$天不跑。

这个dp方程很经典，考虑使用线段树优化。
先考虑如何做到$O(n\log n)$。
我们考虑线段树下标是$j$的决策点，存的东西是决策对应的值（记为$val_j$），考虑当$i$变化时不同决策点的代价如何变化。
1. 首先每一个决策点$j$到$i$都比到$i - 1$要多跑一天的步，所以$val_j$要减去$d$。
2. 然后这时候满足$j<l_p$且$i\geq r_p$的挑战$p$变得可以选择（因为随着$i$的不断右移，只要满足上述条件这些挑战就始终能选择），也就是对于所有的$p$满足$j<l_p$且$i\geq r_p$，$val_j$要加上$v_p$。
3. 然后就得到了$val_j$的变化方式，而$val_j$对比转移方程恰好在$j$作为决策点时取到，所以可以据此进行优化。
那么这就是一个$O(n\log n)$的做法。

然后考虑如何优化到$O((n + m)\log(n + m))$。容易发现的是，我们在转移过程中，只有$l_p$和$r_p$是有用的，所以我们考虑离散化，把$l_p$和$r_p$丢到离散化数组$t$里，然后就做完了。
复杂度$O((n + m)\log(n + m))$。

~~~cpp
{{#include ./code/Luogu_P_9871.cpp}}
~~~
```